Реализация некоторых способов запутывания DPI.
Программа представляет собой локальный SOCKS прокси сервер.

--------------
Использование:
$ ./ciadpi --method disorder --split-pos 3

Описание аргументов:
-i, --ip <ip>
    Прослушиваемый IP, по умолчанию 0.0.0.0

-p, --port <num>
    Прослушиваемый порт, по умолчанию 1080

-c, --max-conn <count>
    Максимальное количество клиентских подключений, по умолчанию 512

-I  --conn-ip <ip>
    Адрес, к которому будут привязаны исходящие соединения, по умолчанию ::
    При указании IPv4 адреса запросы на IPv6 будут отклоняться

-b, --buf-size <size>
    Максимальный размер данных, получаемых и отправляемых за один вызов recv/send
    Размер указывается в байтах, по умолчанию равен 16384

-g, --def-ttl <num>
    Значение TTL для всех исходящий соединений
    Может быть полезен для обхода обнаружения нестандартного/уменьшенного TTL

-N, --no-domain
    Отбрасывать запросы, если в качестве адреса указан домен
    Т.к. резолвинг выполняется синхронно, то он может замедлить или даже заморозить работу

-K, --desync-known
    Отключить запутывание для нераспознанных протоколов
    Распознаваемые протоколы: HTTP и TLS с SNI

-m, --method <s|d|f>
    Способ десинхронизации TCP, есть 3 метода, комбинировать их нельзя:
    split:
        Разбить первый запрос на два по определённому смещению
    disorder:
        Как split, но части отправляются в обратном порядке
        ! Поведение в Windows отлично: сначала отправляется вторая часть, затем целый запрос
    fake:
        ! В Windows не поддерживается
        Как disorder, только перед первым запросом отправляется часть поддельного
        Количество байт отправляемого из фейка равно значению split-pos,
        поэтому рекомендуется использовать отрицательное значение или вкл. split-at-host
    oob:
        Как split, но после первой части также отсылается несколько байт вне основного потока
        ! Малоизученный метод

-s, --split-pos <offset>
    Смещение, по которому будет разбит запрос, по умолчанию 3
    Если значение отрицательное, то оно будет считаться от конца

-H, --split-at-host
    Если найден SNI или Host, то считать смещение относительно позиции домена
    При split-pos=0 запрос будет разбит прямо перед именем хоста

-t, --ttl <num>
    TTL для поддельного пакета, по умолчанию 8
    Необходимо подобрать такое значение, чтобы пакет не дошел до сервера, но был обработан DPI

-l, --fake-tls <file>
-o, --fake-http <file>
    Указать свои поддельные пакеты, вместо дефолтных

-e, --oob-data <file>
    Данные, отсылаемые вне основного потока, по умолчанию один байт 'a'
    ! При размере более одного байта может работать нестабильно
    
-n, --tls-sni <str>
    Изменить SNI в fake пакете на указанный

-M, --mod-http <h[,d,r]>
    Всякие манипуляции с HTTP пакетом, можно комбинировать
    hcsmix:
        "Host: name" -> "hOsT: name"
    dcsmix:
        "Host: name" -> "Host: NaMe"
    rmspace:
        "Host: name" -> "Host:name\t"

-r, --tlsrec <offset>
    Разделить ClientHello на отдельные записи по указанному смещению
    Также возможен отсчет от конца при указании отрицательного значения

-L, --tlsrec-at-sni
    Отсчитывать позицию tlsrec относительно SNI
    
-------
Сборка:
Для сборки понадобится: 
make, gcc/clang для Linux, mingw для Windows

# Linux
$ make
# Windows
$ make windows CC=x86_64-w64-mingw32-gcc

-----------------
Как это работает?
Подробно описано тут:
https://github.com/bol-van/zapret/blob/master/docs/readme.txt
https://geneva.cs.umd.edu/papers/geneva_ccs19.pdf
https://habr.com/ru/post/335436